package de.fraunhofer.fkie.evaluation;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import de.fraunhofer.fkie.aidpfm.model.Requirement;
import de.fraunhofer.fkie.aidpfm.utilities.Config;
import de.fraunhofer.fkie.aidpfm.utilities.ModelContainer;
import de.fraunhofer.fkie.aidpfm.utilities.Util;
import de.fraunhofer.fkie.evaluation.clusterfunction.ClusterFunction;
import de.fraunhofer.fkie.evaluation.clusterfunction.FuzzyCMeans;
import de.fraunhofer.fkie.evaluation.clusterfunction.KMeans;
import de.fraunhofer.fkie.evaluation.clusterfunction.NeuralGas;
import de.fraunhofer.fkie.evaluation.distancefunction.DistanceFunction;
import de.fraunhofer.fkie.evaluation.distancefunction.DistanceHandler;
import de.fraunhofer.fkie.evaluation.distancefunction.EuclideanDistance;
import de.fraunhofer.fkie.evaluation.model.Cluster;
import de.fraunhofer.fkie.evaluation.model.RequirementVector;
import de.fraunhofer.fkie.evaluation.model.Result;
import de.fraunhofer.fkie.evaluation.utils.Metrics;
import weka.core.Instances;

public class ClusterExecutor {

	public static Logger LOG = LoggerFactory.getLogger(ClusterExecutor.class);

	/**
	 * produces the clusters for the given vectors with own clustering
	 * mechanisms
	 *
	 * @param requirements
	 *            - these will be clusterd
	 * @param distanceFunction
	 *            - the used distanceFunction
	 * @param clusterer
	 *            - the weka cluster responsible for the clustering
	 * @param data
	 *            - the original testData (needed for generating the Result)
	 * @param humanReference
	 *            - human results generated by domain experts
	 * @return the result object for this cluster
	 * @throws Exception
	 */

	public Result group(final List<RequirementVector> requirements, final DistanceHandler distanceHandler,
			final ClusterFunction clusterFunction, final ModelContainer container, final Result humanReference)
			throws Exception {
		long start = System.currentTimeMillis();
		List<List<RequirementVector>> clusters = clusterFunction.evaluationCluster(requirements, distanceHandler);
		long end = System.currentTimeMillis();
		// into group
		List<Cluster> cluster = new ArrayList<Cluster>();
		for (List<RequirementVector> list : clusters) {
			cluster.add(new Cluster(this.translate(list, container.getRequirementsUnmodifiable())));
		}
		Result result = new Result(cluster, (end - start));
		List<int[]> mappings2 = this.getGreedyExternalMappings(result, humanReference,
				container.getRequirementsUnmodifiable());

		result.setAccordance(this.compareExternalMetrics(result, humanReference,
				container.getRequirementsUnmodifiable(), mappings2));
		result.setAccordance(this.compareInternalMetrics(clusters, result, new EuclideanDistance()));
		// *******************************************************************************
		return result;
	}

	public Result group(final List<RequirementVector> requirements, final DistanceHandler distanceHandler,
			final ClusterFunction clusterFunction, final ModelContainer container, final Result humanReference,
			final int randomNumberSeed, final boolean verification) throws Exception {

		if (clusterFunction instanceof KMeans) {
			((KMeans) clusterFunction).setRandomFile(randomNumberSeed, verification);
		}

		if (clusterFunction instanceof NeuralGas) {
			((NeuralGas) clusterFunction).setRandomFile(randomNumberSeed, verification);
		}
		if (clusterFunction instanceof FuzzyCMeans) {
			((FuzzyCMeans) clusterFunction).setRandomFile(randomNumberSeed, verification);
		}

		long start = System.currentTimeMillis();
		List<List<RequirementVector>> clusters = clusterFunction.evaluationCluster(requirements, distanceHandler);
		long end = System.currentTimeMillis();
		// into group
		List<Cluster> cluster = new ArrayList<Cluster>();
		for (List<RequirementVector> list : clusters) {
			cluster.add(new Cluster(this.translate(list, container.getRequirementsUnmodifiable())));
		}
		Result result = new Result(cluster, (end - start));
		List<int[]> mappings2 = this.getGreedyExternalMappings(result, humanReference,
				container.getRequirementsUnmodifiable());

		// also sets precision, recall, f1 and naive
		result.setAccordance(this.compareExternalMetrics(result, humanReference,
				container.getRequirementsUnmodifiable(), mappings2));
		result.setAccordance(this.compareInternalMetrics(clusters, result, new EuclideanDistance()));
		// *******************************************************************************
		return result;
	}

	/**
	 * produces the clusters for the given vectors with a weka clusterer
	 *
	 * @param requirements
	 *            - these will be clusterd
	 * @param clusterer
	 *            - the weka cluster responsible for the clustering
	 * @param data
	 *            - the original testData (needed for generating the Result)
	 * @param input
	 *            - the arff generated out of the vecotrs (both are needed for
	 *            generating the result)
	 * @param humanReference
	 *            - human results generated by domain experts
	 * @return the result object for this cluster
	 * @throws Exception
	 */
	public Result group(final List<RequirementVector> requirements, final weka.clusterers.Clusterer clusterer,
			final ModelContainer container, final Instances input, final Result humanReference) throws Exception {
		long start = System.currentTimeMillis();
		clusterer.buildClusterer(input);
		List<List<RequirementVector>> clusters = new ArrayList<List<RequirementVector>>();
		for (int i = 0; i < input.size(); i++) {
			int clusterID = clusterer.clusterInstance(input.get(i));
			// we do not know how many clusters, so we may have to init them
			while (clusterID >= clusters.size()) {
				List<RequirementVector> cluster = new ArrayList<RequirementVector>();
				clusters.add(cluster);
			}
			clusters.get(clusterID).add(requirements.get(i));
		}
		long end = System.currentTimeMillis();
		List<Cluster> cluster = new LinkedList<Cluster>();
		for (List<RequirementVector> list : clusters) {
			cluster.add(new Cluster(this.translate(list, container.getRequirementsUnmodifiable())));
		}
		Result result = new Result(cluster, (end - start));

		List<int[]> mappings2 = this.getGreedyExternalMappings(result, humanReference,
				container.getRequirementsUnmodifiable());

		// also sets precision, recall, f1 and naive
		result.setAccordance(this.compareExternalMetrics(result, humanReference,
				container.getRequirementsUnmodifiable(), mappings2));
		result.setAccordance(this.compareInternalMetrics(clusters, result, new EuclideanDistance()));
		return result;
	}

	/**
	 * method that clusters for the rest api. Same as group, but keeps some
	 * evaluation stuff out
	 *
	 * @param requirements
	 * @param distanceFunction
	 * @param clusterFunction
	 * @param data
	 * @return
	 * @throws Exception
	 */

	public Result cluster(final List<RequirementVector> requirements, final DistanceHandler distanceHandler,
			final ClusterFunction clusterFunction, final ModelContainer container, final List<Integer> centers)
			throws Exception {
		long start = System.currentTimeMillis();
		List<List<RequirementVector>> clusters = clusterFunction.cluster(requirements, distanceHandler, centers);
		long end = System.currentTimeMillis();
		// into group
		List<Cluster> cluster = new ArrayList<Cluster>();
		for (List<RequirementVector> list : clusters) {
			cluster.add(new Cluster(this.translate(list, container.getRequirementsUnmodifiable())));
		}
		Result result = new Result(cluster, (end - start));
		return result;
	}

	/**
	 * method that clusters weka clusters for the rest api. Same as group, but
	 * keeps some evaluation stuff out
	 *
	 * @param requirements
	 * @param clusterer
	 * @param data
	 * @param input
	 * @return
	 * @throws Exception
	 */
	public Result cluster(final List<RequirementVector> requirements, final weka.clusterers.Clusterer clusterer,
			final List<Requirement> data) throws Exception {
		long start = System.currentTimeMillis();
		ClusterDataGenerator generator = new ClusterDataGenerator();
		generator.vectorsIntoArff(requirements, "vectors");
		Instances input = new Instances(Util.readDataFile(Config.EVALUATIONFRAMEWORK + "/vectors.arff"));
		clusterer.buildClusterer(input);
		List<List<RequirementVector>> clusters = new ArrayList<List<RequirementVector>>();
		for (int i = 0; i < input.size(); i++) {
			int clusterID = clusterer.clusterInstance(input.get(i));
			// we do not know how many clusters, so we may have to init them
			while (clusterID >= clusters.size()) {
				List<RequirementVector> cluster = new ArrayList<RequirementVector>();
				clusters.add(cluster);
			}
			clusters.get(clusterID).add(requirements.get(i));
		}
		long end = System.currentTimeMillis();
		List<Cluster> cluster = new ArrayList<Cluster>();
		for (List<RequirementVector> list : clusters) {
			cluster.add(new Cluster(this.translate(list, data)));
		}
		Result result = new Result(cluster, (end - start));
		return result;
	}

	List<int[]> getGreedyExternalMappings(final Result computerClusters, final Result humanClusters,
			final List<Requirement> data) {
		List<int[]> mapping = new ArrayList<>();
		mapping.add(getF1MaxMapping(computerClusters, humanClusters));
		mapping.add(this.getPurityMaxMapping(computerClusters, humanClusters, data));
		mapping.add(getJaccardMaxMapping(computerClusters, humanClusters, data));
		return mapping;
	}

	public static int[] getF1MaxMapping(final Result computerClusters, final Result humanClusters) {
		List<List<Entry<Integer, Double>>> allF1 = new ArrayList<>();
		for (int i = 0; i < computerClusters.getClusters().size(); i++) {
			Cluster cc = computerClusters.getClusters().get(i);
			Map<Integer, Double> f1 = new HashMap<Integer, Double>();
			for (int j = 0; j < humanClusters.getClusters().size(); j++) {
				Cluster hc = humanClusters.getClusters().get(j);
				double value = Metrics.calculateF1(cc, hc)[2];
				if (Double.isNaN(value)) {
					System.out.println("test");
				}
				f1.put(j, value);
			}
			List<Map.Entry<Integer, Double>> entries = new ArrayList<>(f1.entrySet());
			Collections.sort(entries, new Comparator<Map.Entry<Integer, Double>>() {
				@Override
				public int compare(final Map.Entry<Integer, Double> v1, final Map.Entry<Integer, Double> v2) {
					return v1.getValue().compareTo(v2.getValue());
				}
			});
			Collections.reverse(entries);
			allF1.add(entries);
		}
		int[] f1Mapping = new int[humanClusters.getClusters().size()];
		// this loop fills every position
		List<Integer> alreadyMapped = new ArrayList<>();
		List<Integer> alreadyMappedTo = new ArrayList<>();
		for (int i = 0; i < f1Mapping.length; i++) {
			// the value
			double maxF1 = -1;
			// the cluster with the high result (position in List) (will be
			// mapping[i])
			int maxF1CCluster = -1;
			// the humanCluster which was part of the pairing (key in the Map)
			// (will be i)
			int maxF1HCluster = -1;
			// this loop traverses every map (so all ccs and their personal
			// mapping results)
			for (int j = 0; j < allF1.size(); j++) {
				if (alreadyMapped.contains(j)) {
					continue;
				}
				List<Entry<Integer, Double>> resultsOfCC = allF1.get(j);
				if (resultsOfCC.size() == 0) {
					System.out.println("Hello");
				}
				// this loop goes through the indivdual results
				if (alreadyMappedTo.contains(resultsOfCC.get(0).getKey())) {
					continue;
				}
				if (resultsOfCC.get(0).getValue() >= maxF1) {
					maxF1 = resultsOfCC.get(0).getValue();
					maxF1CCluster = j;
					maxF1HCluster = resultsOfCC.get(0).getKey();
				}
			}
			if (maxF1CCluster == -1) {
				// there is some data to be deleted
				boolean stillLeft = false;
				for (int j = 0; j < allF1.size(); j++) {
					if (allF1.get(j).size() > 0) {
						allF1.get(j).remove(0);
						stillLeft = true;
					}
					if (!stillLeft) {
						// nothing left... this means we are finished (happens
						// when there are more hc than cc
						i++;
					}
				}
				i--;
			} else if (f1Mapping[maxF1HCluster] == 0) {
				f1Mapping[maxF1HCluster] = maxF1CCluster + 1;
				alreadyMapped.add(maxF1CCluster);
				alreadyMappedTo.add(maxF1HCluster);
				allF1.get(maxF1CCluster).remove(0);
			}

			else {
				allF1.get(maxF1CCluster).remove(maxF1HCluster);
				i--;
			}
		}
		return f1Mapping;
	}

	public static int[] getJaccardMaxMapping(final Result computerClusters, final Result humanClusters,
			final List<Requirement> testData) {
		List<List<Entry<Integer, Double>>> allJaccard = new ArrayList<>();
		for (int i = 0; i < computerClusters.getClusters().size(); i++) {
			Cluster cc = computerClusters.getClusters().get(i);
			Map<Integer, Double> jaccard = new HashMap<Integer, Double>();
			for (int j = 0; j < humanClusters.getClusters().size(); j++) {
				Cluster hc = humanClusters.getClusters().get(j);
				jaccard.put(j, Metrics.calculateJaccard(cc, hc, computerClusters.getClusters(),
						humanClusters.getClusters(), testData));
			}
			List<Map.Entry<Integer, Double>> entries = new ArrayList<>(jaccard.entrySet());
			Collections.sort(entries, new Comparator<Map.Entry<Integer, Double>>() {
				@Override
				public int compare(final Map.Entry<Integer, Double> v1, final Map.Entry<Integer, Double> v2) {
					return v1.getValue().compareTo(v2.getValue());
				}
			});
			Collections.reverse(entries);
			allJaccard.add(entries);
		}
		int[] jaccardMapping = new int[humanClusters.getClusters().size()];
		// this loop fills every position
		List<Integer> alreadyMapped = new ArrayList<>();
		List<Integer> alreadyMappedTo = new ArrayList<>();
		for (int i = 0; i < jaccardMapping.length; i++) {
			// the value
			double maxJaccard = -1;
			// the cluster with the high result (position in List) (will be
			// mapping[i])
			int maxJaccardCCluster = -1;
			// the humanCluster which was part of the pairing (key in the Map)
			// (will be i)
			int maxJaccardHCluster = -1;
			// this loop traverses every map (so all ccs and their personal
			// mapping results)
			for (int j = 0; j < allJaccard.size(); j++) {
				if (alreadyMapped.contains(j)) {
					continue;
				}

				List<Entry<Integer, Double>> resultsOfCC = allJaccard.get(j);
				// this loop goes through the indivdual results
				if (alreadyMappedTo.contains(resultsOfCC.get(0).getKey())) {
					continue;
				}
				if (resultsOfCC.get(0).getValue() >= maxJaccard) {
					maxJaccard = resultsOfCC.get(0).getValue();
					maxJaccardCCluster = j;
					maxJaccardHCluster = resultsOfCC.get(0).getKey();
				}
			}
			if (maxJaccardCCluster == -1) {
				// there is some data to be deleted
				boolean stillLeft = false;
				for (int j = 0; j < allJaccard.size(); j++) {
					if (allJaccard.get(j).size() > 0) {
						allJaccard.get(j).remove(0);
						stillLeft = true;
					}
					if (!stillLeft) {
						// nothing left... this means we are finished (happens
						// when there are more hc than cc
						i++;
					}
				}
				i--;

			} else if (jaccardMapping[maxJaccardHCluster] == 0) {
				jaccardMapping[maxJaccardHCluster] = maxJaccardCCluster + 1;
				alreadyMapped.add(maxJaccardCCluster);
				alreadyMappedTo.add(maxJaccardHCluster);
				allJaccard.get(maxJaccardCCluster).remove(0);
			} else {
				allJaccard.get(maxJaccardCCluster).remove(maxJaccardHCluster);
				i--;
			}
		}
		return jaccardMapping;
	}

	public int[] getPurityMaxMapping(final Result computerClusters, final Result humanClusters,
			final List<Requirement> data) {
		List<List<Entry<Integer, Double>>> allPurity = new ArrayList<>();
		for (int i = 0; i < computerClusters.getClusters().size(); i++) {
			Cluster cc = computerClusters.getClusters().get(i);
			Map<Integer, Double> purity = new HashMap<Integer, Double>();
			for (int j = 0; j < humanClusters.getClusters().size(); j++) {
				purity.put(j, Metrics.calculatePurity(cc, humanClusters.getClusters(), data));
			}
			List<Map.Entry<Integer, Double>> entries = new ArrayList<>(purity.entrySet());
			Collections.sort(entries, new Comparator<Map.Entry<Integer, Double>>() {
				@Override
				public int compare(final Map.Entry<Integer, Double> v1, final Map.Entry<Integer, Double> v2) {
					return v1.getValue().compareTo(v2.getValue());
				}
			});
			Collections.reverse(entries);
			allPurity.add(entries);
		}
		int[] purityMapping = new int[humanClusters.getClusters().size()];
		// this loop fills every position
		List<Integer> alreadyMapped = new ArrayList<>();
		List<Integer> alreadyMappedTo = new ArrayList<>();
		for (int i = 0; i < purityMapping.length; i++) {
			// the value
			double maxPurity = -1;
			// the cluster with the high result (position in List) (will be
			// mapping[i])
			int maxPurityCCluster = -1;
			// the humanCluster which was part of the pairing (key in the Map)
			// (will be i)
			int maxPurityHCluster = -1;
			// this loop traverses every map (so all ccs and their personal
			// mapping results)
			for (int j = 0; j < allPurity.size(); j++) {
				if (alreadyMapped.contains(j)) {
					continue;
				}
				List<Entry<Integer, Double>> resultsOfCC = allPurity.get(j);
				// this loop goes through the indivdual results
				if (alreadyMappedTo.contains(resultsOfCC.get(0).getKey())) {
					continue;
				}
				if (resultsOfCC.get(0).getValue() >= maxPurity) {
					maxPurity = resultsOfCC.get(0).getValue();
					maxPurityCCluster = j;
					maxPurityHCluster = resultsOfCC.get(0).getKey();
				}
			}
			if (maxPurityCCluster == -1) {
				// there is some data to be deleted
				boolean stillLeft = false;
				for (int j = 0; j < allPurity.size(); j++) {
					if (allPurity.get(j).size() > 0) {
						allPurity.get(j).remove(0);
						stillLeft = true;
					}
					if (!stillLeft) {
						// nothing left... this means we are finished (happens
						// when there are more hc than cc
						i++;
					}
				}
				i--;

			} else if (purityMapping[maxPurityHCluster] == 0) {
				purityMapping[maxPurityHCluster] = maxPurityCCluster + 1;
				alreadyMapped.add(maxPurityCCluster);
				alreadyMappedTo.add(maxPurityHCluster);
				allPurity.get(maxPurityCCluster).remove(0);
			} else {
				allPurity.get(maxPurityCCluster).remove(maxPurityHCluster);
				i--;
			}
		}
		return purityMapping;
	}

	public int[] getRandMaxMapping(final Result computerClusters, final Result humanClusters,
			final List<Requirement> testData) {
		List<List<Entry<Integer, Double>>> allRand = new ArrayList<>();
		for (int i = 0; i < computerClusters.getClusters().size(); i++) {
			Cluster cc = computerClusters.getClusters().get(i);
			Map<Integer, Double> rand = new HashMap<Integer, Double>();
			for (int j = 0; j < humanClusters.getClusters().size(); j++) {
				Cluster hc = humanClusters.getClusters().get(j);
				rand.put(j, Metrics.calculateJaccard(cc, hc, computerClusters.getClusters(),
						humanClusters.getClusters(), testData));
			}
			List<Map.Entry<Integer, Double>> entries = new ArrayList<>(rand.entrySet());
			Collections.sort(entries, new Comparator<Map.Entry<Integer, Double>>() {
				@Override
				public int compare(final Map.Entry<Integer, Double> v1, final Map.Entry<Integer, Double> v2) {
					return v1.getValue().compareTo(v2.getValue());
				}
			});
			Collections.reverse(entries);
			allRand.add(entries);
		}
		int[] randMapping = new int[humanClusters.getClusters().size()];
		// this loop fills every position
		List<Integer> alreadyMapped = new ArrayList<>();
		List<Integer> alreadyMappedTo = new ArrayList<>();
		for (int i = 0; i < randMapping.length; i++) {
			// the value
			double maxRand = -1;
			// the cluster with the high result (position in List) (will be
			// mapping[i])
			int maxRandCCluster = -1;
			// the humanCluster which was part of the pairing (key in the Map)
			// (will be i)
			int maxRandHCluster = -1;
			// this loop traverses every map (so all ccs and their personal
			// mapping results)
			for (int j = 0; j < allRand.size(); j++) {
				if (alreadyMapped.contains(j)) {
					continue;
				}
				List<Entry<Integer, Double>> resultsOfCC = allRand.get(j);
				// this loop goes through the indivdual results
				if (alreadyMappedTo.contains(resultsOfCC.get(0).getKey())) {
					continue;
				}
				if (resultsOfCC.get(0).getValue() >= maxRand) {
					maxRand = resultsOfCC.get(0).getValue();
					maxRandCCluster = j;
					maxRandHCluster = resultsOfCC.get(0).getKey();
				}
			}
			if (maxRandCCluster == -1) {
				// there is some data to be deleted
				boolean stillLeft = false;
				for (int j = 0; j < allRand.size(); j++) {
					if (allRand.get(j).size() > 0) {
						allRand.get(j).remove(0);
						stillLeft = true;
					}
					if (!stillLeft) {
						// nothing left... this means we are finished (happens
						// when there are more hc than cc
						i++;
					}
				}
				i--;
			} else if (randMapping[maxRandHCluster] == 0) {
				randMapping[maxRandHCluster] = maxRandCCluster + 1;
				alreadyMapped.add(maxRandCCluster);
				alreadyMappedTo.add(maxRandHCluster);
				allRand.get(maxRandCCluster).remove(0);
			} else {
				allRand.get(maxRandCCluster).remove(maxRandHCluster);
				i--;
			}
		}
		return randMapping;
	}

	public boolean compareExternalMetrics(final Result computerResult, final Result humanResult,
			final List<Requirement> testData, final List<int[]> mappings) {
		double maxF1 = 0, maxNA = 0, maxPrecision = 0, maxRecall = 0, maxPurity = 0, maxRand = 0, maxJaccard = 0,
				maxF1Weighted = 0, maxPrecisionWeighted = 0, maxRecallWeighted = 0, maxJaccardWeighted = 0;
		int maxMappingF1 = 0, maxMappingNA = 0, maxMappingPurity = 0, maxMappingJaccard = 0, maxMappingRand = 0,
				maxMappingF1Weighted = 0, maxMappingJaccardWeighted = 0;
		for (int i = 0; i < mappings.size(); i++) {
			List<Cluster> computerCluster = getClusterMapping(computerResult.getClusters(), mappings.get(i));
			List<Cluster> humanCluster = humanResult.getClusters();
			double[] f1Array = Metrics.calculateF1Avg(computerCluster, humanCluster, testData);
			double f1 = f1Array[2];
			double naive = Metrics.calculateNaive(computerCluster, humanCluster, testData);
			double purity = Metrics.calculatePurityAvg(computerCluster, humanCluster, testData);
			double jaccard = Metrics.calculateJaccardAvg(computerCluster, humanCluster, testData);
			double f1WeightedArray[] = Metrics.calculateF1WeightedAvg(computerCluster, humanCluster, testData);
			double f1Weighted = f1WeightedArray[2];

			double jaccardWeighted = Metrics.calculateJaccardWeightedAvg(computerCluster, humanCluster, testData);

			if (f1 >= maxF1) {
				maxF1 = f1;
				maxPrecision = f1Array[0];
				maxRecall = f1Array[1];
				maxMappingF1 = i;
			}
			if (naive >= maxNA) {
				maxNA = naive;
				maxMappingNA = i;
			}
			if (purity >= maxPurity) {
				maxPurity = purity;
				maxMappingPurity = i;
			}
			if (jaccard >= maxJaccard) {
				maxJaccard = jaccard;
				maxMappingJaccard = i;
			}

			if (f1Weighted >= maxF1Weighted) {
				maxF1Weighted = f1Weighted;
				maxPrecisionWeighted = f1WeightedArray[0];
				maxRecallWeighted = f1WeightedArray[1];
				maxMappingF1Weighted = i;
			}

			if (jaccardWeighted >= maxJaccardWeighted) {
				maxJaccardWeighted = jaccardWeighted;
				maxMappingJaccardWeighted = i;
			}

		}
		computerResult.setF1(maxF1);
		computerResult.setPrecision(maxPrecision);
		computerResult.setRecall(maxRecall);
		computerResult.setNaiveAccuracy(maxNA);
		computerResult.setRand(maxRand);
		computerResult.setPurity(maxPurity);
		computerResult.setJaccard(maxJaccard);
		computerResult.setF1Mapping(mappings.get(maxMappingF1));
		computerResult.setNaiveMapping(mappings.get(maxMappingNA));
		computerResult.setPurityMapping(mappings.get(maxMappingPurity));
		computerResult.setJaccardMapping(mappings.get(maxMappingJaccard));
		computerResult.setRandMapping(mappings.get(maxMappingRand));
		computerResult.setF1Weighted(maxF1Weighted);
		computerResult.setPrecisionWeighted(maxPrecisionWeighted);
		computerResult.setRecallWeighted(maxRecallWeighted);
		computerResult.setF1MappingWeighted(mappings.get(maxMappingF1Weighted));
		computerResult.setJaccardMappingWeighted(mappings.get(maxMappingJaccardWeighted));
		if ((maxMappingF1 == maxMappingNA) && (maxMappingJaccard == maxMappingPurity)
				&& (maxMappingJaccard == maxMappingRand) && (maxMappingF1 == maxMappingPurity)) {
			return true;
		} else {
			return false;
		}
	}

	boolean compareInternalMetrics(final List<List<RequirementVector>> clusters, final Result result,
			final DistanceFunction distanceFunction) {
		double[] values = Metrics.internalMeasurements(clusters, distanceFunction);
		result.setCohesion(values[0]);
		result.setSeperation(values[1]);
		result.setSilhouette(values[2]);
		return true;
	}

	// translates a list of RequirementVectors into a list of Requirements
	List<Requirement> translate(final List<RequirementVector> list, final List<Requirement> data) {
		List<Requirement> toReturn = new ArrayList<Requirement>();
		for (RequirementVector vector : list) {
			Requirement req = this.find(vector, data);
			toReturn.add(req);
		}
		return toReturn;
	}

	private Requirement find(final RequirementVector vector, final List<Requirement> data) {
		for (Requirement req : data) {
			if (req.getObjId().equals(vector.getID())) {
				return req;
			}
		}
		return null;
	}

	/**
	 *
	 * @param reference
	 *            - the output as given by the group algorithm
	 * @param mapping
	 *            - where should everything go?
	 * @return the new cluster order as defined by mapping
	 */
	public static List<Cluster> getClusterMapping(final List<Cluster> reference, final int[] mapping) {
		List<Cluster> toReturn = new ArrayList<Cluster>();
		// cc mapping[i] goes to i
		for (int i = 0; i < mapping.length; i++) {
			if (mapping[i] == 0) { // when there are more hc than cc
				toReturn.add(new Cluster());
			} else {
				toReturn.add(reference.get(mapping[i] - 1));
			}
		}
		return toReturn;
	}

}
